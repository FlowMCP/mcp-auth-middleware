# MCP Session-Management Implementation Plan

## 🎯 Executive Summary

Implementation of a global Session-Management system for OAuth 2.1 middleware following MCP (Model Context Protocol) JSON-RPC specifications and optimizing performance through token caching using a BaseOAuthMiddleware architecture.

## 📋 Problem Analysis

### Identified Challenges

1. **Performance Issue**: OAuth token validation on every request is expensive
2. **MCP Compliance**: Session-IDs are generated by the MCP server, not the middleware
3. **Architecture Limitation**: Middleware sits between client and server without direct access to response headers
4. **JSON-RPC Integration**: Initialize method requires special handling
5. **Global Implementation**: Need to support multiple OAuth providers (ScaleKit, AuthKit, future providers)

### Core Insights

- **Session-ID Generation**: MCP server generates Session-IDs during `initialize` method
- **Middleware Role**: Smart proxy that links Session-IDs with validated tokens
- **Response Interception**: Required to capture `Mcp-Session-Id` header
- **Method Detection**: JSON-RPC body parsing for `initialize` vs. regular methods
- **Provider Abstraction**: BaseOAuthMiddleware for shared session logic

## 🏗️ Architecture Design

### Global OAuth Session-Management Architecture

```javascript
┌─────────────────────────────────────────┐
│           McpSessionCache               │
│  sessionId → { token, timestamp, ... }  │
└─────────────────────────────────────────┘
                    ↑
┌─────────────────────────────────────────┐
│         BaseOAuthMiddleware             │
│  ├── Session Management Logic           │
│  ├── JSON-RPC Method Detection          │
│  ├── Initialize/Regular Request Flow    │
│  └── Abstract Provider Methods          │
└─────────────────────────────────────────┘
                    ↑
    ┌───────────────┼───────────────┐
    │               │               │
┌───▼────┐   ┌─────▼─────┐   ┌─────▼─────┐
│ScaleKit│   │  AuthKit  │   │  Future   │
│Provider│   │  Provider │   │ Providers │
└────────┘   └───────────┘   └───────────┘
```

### Session-Management Flow

```
1. Client → [Middleware] → MCP Server
   POST /mcp { "method": "initialize", ... }
   Header: Authorization: Bearer <token>

2. [Middleware] → MCP Server
   Token validiert, Request weitergeleitet

3. MCP Server → [Middleware] → Client
   Response mit Header: Mcp-Session-Id: <uuid>

4. [Middleware] Session-Cache
   sessionId → { accessToken, timestamp }

5. Client → [Middleware] → MCP Server
   POST /mcp { "method": "tools/call", ... }
   Header: Mcp-Session-Id: <uuid>

6. [Middleware] Cache-Lookup
   Session gefunden → Skip Token-Validierung
```

### Provider Implementation

```javascript
// ScaleKit OAuth Provider
class ScaleKitMiddleware extends BaseOAuthMiddleware {
    async validateToken(token, options) {
        return await this.#scalekit.validateToken(token, options)
    }

    extractToken({ req }) {
        // ScaleKit-specific token extraction
    }

    buildWWWAuthenticateHeader() {
        // ScaleKit-specific WWW-Authenticate header
    }
}

// AuthKit OAuth Provider
class AuthKitMiddleware extends BaseOAuthMiddleware {
    async validateToken(token, options) {
        return await jwtVerify(token, this.#jwks, options)
    }

    extractToken({ req }) {
        // AuthKit-specific token extraction
    }

    buildWWWAuthenticateHeader() {
        // AuthKit-specific WWW-Authenticate header
    }
}
```

## 🔧 Implementation

### Phase 1: BaseOAuthMiddleware with Global Session-Cache

The BaseOAuthMiddleware has been implemented with:
- **McpSessionCache**: Global session management
- **JSON-RPC Method Detection**: Parse initialize vs. regular methods
- **Provider Abstraction**: Abstract methods for provider-specific logic
- **Session Lifecycle**: Automatic cleanup and expiration

### Phase 2: Provider-Specific Implementation

```javascript
// Refactor ScaleKitMiddleware to extend BaseOAuthMiddleware
class ScaleKitMiddleware extends BaseOAuthMiddleware {
    #scalekit
    #expectedAudience
    #toolScopes
    #protectedResourceMetadata
    #providerUrl

    constructor({ options, attachedRoutes = [], silent = false }) {
        super({ attachedRoutes, silent })

        const { providerUrl, clientId, clientSecret, resource, protectedResourceMetadata, toolScopes = {} } = options

        // Initialize ScaleKit-specific properties
        this.#scalekit = new Scalekit(providerUrl, clientId, clientSecret)
        this.#expectedAudience = resource
        this.#protectedResourceMetadata = protectedResourceMetadata
        this.#toolScopes = toolScopes
        this.#providerUrl = providerUrl
    }

    // Implement abstract methods from BaseOAuthMiddleware
    extractToken({ req }) {
        const authHeader = req.headers['authorization']
        const token = authHeader?.startsWith('Bearer ') ?
            authHeader.split('Bearer ')[1]?.trim() :
            null
        return { token }
    }

    buildValidationOptions({ req }) {
        const validationOptions = { audience: [this.#expectedAudience] }

        const isToolCall = req.body?.method === 'tools/call'
        if (isToolCall) {
            const toolName = req.body?.params?.name
            const requiredScopes = this.#toolScopes[toolName]
            if (requiredScopes && process.env.ENFORCE_SCOPES !== 'false') {
                validationOptions.requiredScopes = requiredScopes
            }
        }

        return validationOptions
    }

    async validateToken(token, validationOptions) {
        return await this.#scalekit.validateToken(token, validationOptions)
    }

    buildWWWAuthenticateHeader() {
        const baseUrl = this.#expectedAudience.replace(/\/$/, '')
        const resourcePath = this.attachedRoutes[0] || ''
        const fullPath = resourcePath === '/' ? '' : resourcePath
        return `Bearer realm="OAuth", resource_metadata="${baseUrl}${fullPath}/.well-known/oauth-protected-resource"`
    }

    handleWellKnownEndpoint({ res }) {
        const metadata = JSON.parse(this.#protectedResourceMetadata)
        res.setHeader('Content-Type', 'application/json')
        res.status(200).json(metadata)
    }

    async handleAuthorizationServerMetadata({ res }) {
        // ScaleKit-specific authorization server metadata handling
        // ... (existing implementation)
    }

    async handleClientRegistration({ req, res }) {
        // ScaleKit-specific client registration handling
        // ... (existing implementation)
    }
}
```

### Phase 3: AuthKit Refactoring

```javascript
// Refactor AuthKitMiddleware to extend BaseOAuthMiddleware
class AuthKitMiddleware extends BaseOAuthMiddleware {
    #jwks
    #expectedAudience
    #authKitDomain
    #toolScopes
    #protectedResourceMetadata
    clientId
    clientSecret

    constructor({ options, attachedRoutes = [], silent = false }) {
        super({ attachedRoutes, silent })

        const { authKitDomain, clientId, clientSecret, expectedAudience, protectedResourceMetadata, toolScopes = {} } = options

        // Initialize AuthKit-specific properties
        this.#authKitDomain = authKitDomain
        this.#expectedAudience = expectedAudience
        this.#protectedResourceMetadata = protectedResourceMetadata
        this.#toolScopes = toolScopes
        this.clientId = clientId
        this.clientSecret = clientSecret

        if (process.env.NODE_ENV === 'test') {
            this.#jwks = { verify: async () => ({ payload: { active: true, sub: 'test', aud: expectedAudience } }) }
        } else {
            this.#jwks = createRemoteJWKSet(new URL(`https://${authKitDomain}/oauth2/jwks`))
        }
    }

    // Implement abstract methods from BaseOAuthMiddleware
    extractToken({ req }) {
        const authHeader = req.headers['authorization']
        const token = authHeader?.startsWith('Bearer ') ?
            authHeader.split('Bearer ')[1]?.trim() :
            null
        return { token }
    }

    buildValidationOptions({ req }) {
        const validationOptions = { audience: [this.#expectedAudience] }

        const isToolCall = req.body?.method === 'tools/call'
        if (isToolCall) {
            const toolName = req.body?.params?.name
            const requiredScopes = this.#toolScopes[toolName]
            if (requiredScopes && process.env.ENFORCE_SCOPES !== 'false') {
                validationOptions.requiredScopes = requiredScopes
            }
        }

        return validationOptions
    }

    async validateToken(token, validationOptions) {
        if (process.env.NODE_ENV === 'test') {
            return await this.#jwks.verify()
        } else {
            return await jwtVerify(token, this.#jwks, {
                issuer: `https://${this.#authKitDomain}`,
                audience: validationOptions.audience
            })
        }
    }

    buildWWWAuthenticateHeader() {
        const metadata = JSON.parse(this.#protectedResourceMetadata)
        const resourceUrl = metadata.resource
        return `Bearer realm="OAuth", resource_metadata="${resourceUrl}/.well-known/oauth-protected-resource"`
    }

    handleWellKnownEndpoint({ res }) {
        const metadata = JSON.parse(this.#protectedResourceMetadata)
        res.setHeader('Content-Type', 'application/json')
        res.status(200).json(metadata)
    }

    async handleAuthorizationServerMetadata({ res }) {
        // AuthKit-specific authorization server metadata handling
        // ... (existing implementation)
    }

    async handleClientRegistration({ req, res }) {
        // AuthKit doesn't support dynamic client registration
        res.status(501).json({ error: 'not_supported', error_description: 'Dynamic client registration not supported by AuthKit' })
    }
}
```

### Phase 3: Initialize Request Handler

```javascript
async #handleInitializeRequest({ req, res, next }) {
    // 1. Token normal validieren (da neue Session)
    const { token } = this.#extractToken({ req })
    const validationOptions = this.#buildValidationOptions({ req })

    await this.#scalekit.validateToken(token, validationOptions)

    // 2. Response intercepten für Session-ID
    const originalSetHeader = res.setHeader.bind(res)
    const validatedToken = token

    res.setHeader = (name, value) => {
        if (name.toLowerCase() === 'mcp-session-id') {
            // Session-ID mit validiertem Token verknüpfen
            this.#sessionCache.linkSession({
                sessionId: value,
                accessToken: validatedToken,
                method: 'initialize'
            })

            if (!this.#silent) {
                const timestamp = new Date().toISOString()
                console.log(`[${timestamp}] MCP SESSION  - New session: ${value.substring(0, 8)}...`)
            }
        }
        return originalSetHeader(name, value)
    }

    if (!this.#silent) {
        const timestamp = new Date().toISOString()
        console.log(`[${timestamp}] MCP INIT     - Initialize request validated`)
    }

    return next()
}
```

### Phase 4: Regular Request Handler

```javascript
async #handleRegularRequest({ req, res, next }) {
    const sessionId = req.headers['mcp-session-id']

    if (sessionId) {
        // Session-Cache prüfen
        const cachedToken = this.#sessionCache.getTokenForSession(sessionId)
        if (cachedToken) {
            if (!this.#silent) {
                const timestamp = new Date().toISOString()
                console.log(`[${timestamp}] MCP CACHE    - Using cached token for session: ${sessionId.substring(0, 8)}...`)
            }
            return next() // Skip Token-Validierung!
        }

        if (!this.#silent) {
            const timestamp = new Date().toISOString()
            console.log(`[${timestamp}] MCP MISS     - Session not found in cache: ${sessionId.substring(0, 8)}...`)
        }
    }

    // Fallback: Normale Token-Validierung
    const { token } = this.#extractToken({ req })
    const validationOptions = this.#buildValidationOptions({ req })

    await this.#scalekit.validateToken(token, validationOptions)

    if (!this.#silent) {
        const timestamp = new Date().toISOString()
        console.log(`[${timestamp}] MCP VALIDATE - Token validated (no session)`)
    }

    return next()
}
```

### Phase 5: Middleware Integration

```javascript
async #authenticateRequest({ req, res, next }) {
    try {
        const { method, isInitialize, isValidJsonRpc } = this.#parseJsonRpcMethod({ req })

        if (!isValidJsonRpc) {
            // Nicht-MCP Request - normale OAuth Behandlung
            return this.#handleNonMcpRequest({ req, res, next })
        }

        if (isInitialize) {
            // Initialize Method - Response intercepten
            return this.#handleInitializeRequest({ req, res, next })
        } else {
            // Regular MCP Method - Session-Cache nutzen
            return this.#handleRegularRequest({ req, res, next })
        }

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error)
        if (!this.#silent) {
            const timestamp = new Date().toISOString()
            console.log(`[${timestamp}] AUTH FAILED  - ${errorMessage}`)
        }

        const wwwHeader = this.#buildWWWAuthenticateHeader()

        return res
            .status(401)
            .set('WWW-Authenticate', wwwHeader)
            .end()
    }
}
```

## 🧪 Testing Strategy

### Test Scenarios

1. **Initialize Flow (ScaleKit)**
   ```javascript
   POST /mcp
   Authorization: Bearer <scalekit-token>
   Body: { "method": "initialize", "id": 1, ... }

   Expected: ScaleKit token validated, Session-ID captured
   ```

2. **Initialize Flow (AuthKit)**
   ```javascript
   POST /mcp
   Authorization: Bearer <authkit-jwt>
   Body: { "method": "initialize", "id": 1, ... }

   Expected: AuthKit JWT verified, Session-ID captured
   ```

3. **Session Cache Hit (Both Providers)**
   ```javascript
   POST /mcp
   Mcp-Session-Id: <known-session>
   Body: { "method": "tools/call", "id": 2, ... }

   Expected: No token validation, use cached token
   ```

4. **Session Cache Miss (Both Providers)**
   ```javascript
   POST /mcp
   Mcp-Session-Id: <unknown-session>
   Body: { "method": "tools/call", "id": 3, ... }

   Expected: Fallback to provider-specific token validation
   ```

5. **Non-MCP Request (Both Providers)**
   ```javascript
   GET /health
   Authorization: Bearer <token>

   Expected: Provider-specific OAuth validation
   ```

6. **Cross-Provider Session Isolation**
   ```javascript
   Test that ScaleKit sessions don't interfere with AuthKit sessions
   ```

### Unit Tests

```javascript
describe('BaseOAuthMiddleware', () => {
    test('detects JSON-RPC initialize method')
    test('handles session cache correctly')
    test('intercepts response headers')
    test('routes to provider-specific validation')
})

describe('McpSessionCache', () => {
    test('links session to token correctly')
    test('retrieves token by session ID')
    test('handles session expiration')
    test('cleans up old sessions')
    test('provides session statistics')
})

describe('ScaleKitMiddleware with Session Management', () => {
    test('inherits session management from base class')
    test('implements ScaleKit-specific token validation')
    test('handles ScaleKit OAuth errors correctly')
})

describe('AuthKitMiddleware with Session Management', () => {
    test('inherits session management from base class')
    test('implements AuthKit-specific JWT validation')
    test('handles AuthKit OAuth errors correctly')
})

describe('Provider Independence', () => {
    test('ScaleKit and AuthKit sessions are isolated')
    test('session cache works with multiple providers')
    test('provider-specific errors don\'t affect other providers')
})
```

## 📊 Performance Benefits

### Before Implementation
- **Every Request**: OAuth token validation (~100-200ms)
- **API Calls**: Provider API calls on every request (ScaleKit API, AuthKit JWT verification)
- **Latency**: High due to external validation
- **Provider Overhead**: Separate validation logic in each provider

### After Implementation
- **Initialize**: OAuth token validation (one-time per session)
- **Follow-up Requests**: Cache lookup (~1ms)
- **API Calls**: Only on cache miss
- **Latency**: 99% reduction for established sessions
- **Code Reuse**: Shared session logic across all OAuth providers
- **Scalability**: Single session cache for all providers

## 🔒 Security Considerations

### Secure Session Management

1. **Session Expiration**: 1-hour TTL with automatic cleanup
2. **Memory-Only Storage**: No persistent session storage
3. **Token Validation**: Maintained for initialize and cache misses
4. **Session Invalidation**: On OAuth errors and expiration
5. **Provider Isolation**: Sessions are provider-agnostic but tokens remain provider-specific
6. **Abstract Validation**: Each provider maintains its own security model

### Potential Risks

1. **Memory Leaks**: Automatic cleanup mechanisms prevent unbounded growth
2. **Session Hijacking**: MCP server generates cryptographically secure UUIDs
3. **Token Replay**: Original OAuth security models remain intact
4. **Cross-Provider Attacks**: Isolated session cache prevents provider interference
5. **Cache Poisoning**: Session-token mapping validated on creation only

## 🚀 Rollout Plan

### Phase 1: Base Architecture (Week 1)
- ✅ BaseOAuthMiddleware implementation
- ✅ McpSessionCache with global session management
- ✅ JSON-RPC method detection
- ⏳ Unit tests for base functionality

### Phase 2: Provider Refactoring (Week 2)
- ⏳ Refactor ScaleKitMiddleware to extend BaseOAuthMiddleware
- ⏳ Refactor AuthKitMiddleware to extend BaseOAuthMiddleware
- ⏳ Maintain backward compatibility
- ⏳ Provider-specific integration tests

### Phase 3: Testing & Validation (Week 3)
- ⏳ End-to-end tests with multiple providers
- ⏳ Performance benchmarks
- ⏳ Cross-provider session isolation tests
- ⏳ Security audit

### Phase 4: Deployment (Week 4)
- ⏳ Feature flag rollout
- ⏳ Monitoring setup
- ⏳ Production deployment
- ⏳ Documentation updates

## 📈 Monitoring & Observability

### Metrics

```javascript
- mcp_sessions_total: Number of active sessions
- mcp_cache_hits_total: Cache hit rate by provider
- mcp_cache_misses_total: Cache miss rate by provider
- mcp_token_validations_total: Token validations by provider
- mcp_session_duration_seconds: Session lifetime distribution
- mcp_provider_errors_total: Provider-specific error rates
- mcp_initialize_requests_total: Initialize requests by provider
```

### Logging

```javascript
[2025-01-27T10:15:30.123Z] MCP INIT     - Initialize request validated (ScaleKit)
[2025-01-27T10:15:30.145Z] MCP SESSION  - New session: 4a8b9c2d...
[2025-01-27T10:15:31.001Z] MCP CACHE    - Using cached token for session: 4a8b9c2d...
[2025-01-27T10:15:32.234Z] MCP INIT     - Initialize request validated (AuthKit)
[2025-01-27T10:15:32.256Z] MCP SESSION  - New session: 7f1e8b9a...
[2025-01-27T10:20:15.678Z] MCP CLEANUP  - Removed 3 expired sessions
```

## 🎯 Success Criteria

### Performance
- [ ] 90% reduction in token validation for established sessions
- [ ] < 5ms latency for cache lookups
- [ ] 99.9% cache hit rate for active sessions
- [ ] Consistent performance across all OAuth providers

### Functionality
- [x] BaseOAuthMiddleware architecture implemented
- [ ] 100% MCP JSON-RPC compatibility
- [ ] Backward compatibility with non-MCP requests
- [ ] Correct session lifecycle management
- [ ] ScaleKitMiddleware refactored to use BaseOAuthMiddleware
- [ ] AuthKitMiddleware refactored to use BaseOAuthMiddleware
- [ ] Cross-provider session isolation

### Security
- [ ] No security regression in any provider
- [ ] Secure session expiration
- [ ] Audit trail for all session events
- [ ] Provider-specific security models maintained
- [ ] Session cache isolation between providers

## 📚 Referenzen

- [MCP Specification - Authorization](https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization)
- [MCP Transports Documentation](https://modelcontextprotocol.io/docs/concepts/transports)
- [OAuth 2.1 Specification](https://tools.ietf.org/html/draft-ietf-oauth-v2-1)
- [JSON-RPC 2.0 Specification](https://www.jsonrpc.org/specification)

---

**Created**: 2025-01-27
**Version**: 2.0
**Status**: Base Architecture Implemented, Provider Refactoring In Progress
**Architecture**: Global BaseOAuthMiddleware with provider inheritance